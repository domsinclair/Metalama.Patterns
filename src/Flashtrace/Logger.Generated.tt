// THIS FILE IS T4-GENERATED.
// To edit, go to Logger.Generated.tt.
// To transform, run this: "C:\Program Files (x86)\Common Files\Microsoft Shared\TextTemplating\14.0\TextTransform.exe" Logger.Generated.tt
// The transformation is not automatic because we are in a shared project.

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>


using System;
using System.ComponentModel;
using PostSharp.Patterns.Diagnostics.Contexts;
using PostSharp.Patterns.Diagnostics.Custom;
using PostSharp.Patterns.Diagnostics.Custom.Messages;
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;

namespace PostSharp.Patterns.Diagnostics
{
	public partial class Logger
	{
	<#
    for (var i = 1; i <= 10; i++)
    {
#>

		/// <summary>
        /// Writes a custom log record with <#= i #> parameter<#= GetPlural( i ) #>.
        /// </summary>
        /// <param name="level">The severity of the record (e.g. <see cref="LogLevel.Info"/> or <see cref="LogLevel.Warning"/>).</param>
        /// <param name="formattingString">The text of the log record, including parameters (e.g. <c>Opening {Path} file {ShareMode} sharing mode</c>).</param>
<#
        GenerateXmlDoc( i );
#>
	    public void Write<<#= Repeat( "T{0}", i ) #>>(  LogLevel level, string formattingString, <#= Repeat( "T{0} arg{0}", i ) #> )
        {
			CallerInfo nullRecordInfo = default;
            this.Write( level, formattingString, <#= Repeat( "arg{0}", i ) #>, ref nullRecordInfo );
        }

		 /// <excludeOverload />
        [EditorBrowsable(EditorBrowsableState.Never)]
		[SuppressMessage("Microsoft.Design", "CA1031")]
        public void Write<<#= Repeat( "T{0}", i ) #>>( LogLevel level, string formattingString,<#= Repeat( "T{0} arg{0}", i ) #>, ref CallerInfo callerInfo )
        {
            if ( !this.ValidateLogger( level ) )
                return;

			try
			{
				this.logger.Write( null, level, LogRecordKind.CustomRecord, formattingString, <#= Repeat( "arg{0}", i ) #>, null, ref callerInfo );
			}
			catch ( Exception e )
			{
				this.ExceptionHandler?.OnInternalException( e );
			}
        }

		/// <summary>
        /// Writes a custom log record with <#= i #> parameter<#= GetPlural( i ) #> and associates it with an <see cref="Exception"/>.
        /// </summary>
        /// <param name="level">The severity of the record (e.g. <see cref="LogLevel.Warning"/> or <see cref="LogLevel.Error"/>).</param>
        /// <param name="formattingString">The text of the log record, including parameters (e.g. <c>Opening {Path} file {ShareMode} sharing mode</c>).</param>
	    /// <param name="exception">The <see cref="Exception"/> associated with the record.</param>
<#
        GenerateXmlDoc( i );
#>
	    public void WriteException<<#= Repeat( "T{0}", i ) #>>( LogLevel level, Exception exception, string formattingString, <#= Repeat( "T{0} arg{0}", i ) #> )
        {
            this.WriteException( level, exception, formattingString, <#= Repeat( "arg{0}", i ) #>, ref nullRecordInfo );
        }

		 /// <excludeOverload />
        [EditorBrowsable(EditorBrowsableState.Never)]
		[SuppressMessage("Microsoft.Design", "CA1031")]
        public void WriteException<<#= Repeat( "T{0}", i ) #>>( LogLevel level, Exception exception, string formattingString,<#= Repeat( "T{0} arg{0}", i ) #>, ref CallerInfo callerInfo )
        {
            if ( !this.ValidateLogger( level ) )
                 return;

			try
			{
				this.logger.Write( null, level, LogRecordKind.CustomRecord, formattingString, <#= Repeat( "arg{0}", i ) #>, exception, ref callerInfo );
			}
			catch ( Exception e )
			{
				this.ExceptionHandler?.OnInternalException( e );
			}
        }

		/// <summary>
        /// Opens a custom activity with <#= i #> parameter<#= GetPlural( i ) #>. 
        /// </summary>
		/// <param name="options">Options.</param>
        /// <param name="formattingString">The formatting string of the activity description, including parameters (e.g. <c>Writing {LineCount} line(s) in file {Path}.</c>)</param>
        /// <returns>A <see cref="Logger"/> representing the new activity.</returns>
        /// <remarks>The activity must be closed using <see cref="LogActivity.SetSuccess(string)"/>, <see cref="LogActivity.SetFailure(String)"/> or <see cref="LogActivity.SetException(Exception)"/>. </remarks>
		<#
        GenerateXmlDoc( i );
#>
		[MethodImpl(MethodImplOptions.NoInlining)]
		public LogActivity OpenActivity<<#= Repeat( "T{0}", i ) #>>( LogActivityOptions options, string formattingString, <#= Repeat( "T{0} arg{0}", i ) #> )
        {
           CallerInfo callerInfo = CallerInfo.GetDynamic(1);
		   return OpenActivity( options, formattingString, <#= Repeat( "arg{0}", i ) #>, ref callerInfo );
        }


		 /// <excludeOverload />
        [EditorBrowsable(EditorBrowsableState.Never)]
		[SuppressMessage("Microsoft.Design", "CA1031")]
		public LogActivity OpenActivity<<#= Repeat( "T{0}", i ) #>>( LogActivityOptions options, string formattingString, <#= Repeat( "T{0} arg{0}", i ) #>, ref CallerInfo callerInfo )
        {
			LogLevel level = this.DefaultLevel;
      
            if ( !this.IsEnabled( level ) )
            {
                return this.GetNullActivity();
            }

			ILoggingContext activity = null;
			try
			{
				SetOptions( ref options, ref callerInfo );

				activity = this.logger.OpenActivity( options, ref callerInfo);
				this.logger.Write( activity, level, LogRecordKind.CustomActivityEntry, formattingString, <#= Repeat( "arg{0}", i ) #>, null, ref callerInfo);
				return this.CreateActivity( activity );
			}
			catch ( Exception e )
			{
				this.DisposeSafe( activity );
				this.ExceptionHandler?.OnInternalException( e );
				
				return this.GetNullActivity();
			}
        }

		 /// <excludeOverload />
        [EditorBrowsable(EditorBrowsableState.Never)]
		[SuppressMessage("Microsoft.Design", "CA1031")]
		public LogActivity OpenAsyncActivity<<#= Repeat( "T{0}", i ) #>>( LogActivityOptions options, string formattingString, <#= Repeat( "T{0} arg{0}", i ) #>, ref CallerInfo callerInfo )
        {
           LogLevel level = this.DefaultLevel;

            if ( !this.IsEnabled( level ) )
            {
                return this.GetNullActivity();
            }

			ILoggingContext activity = null;

			try
			{
				options.IsAsync = true;
				activity = this.logger.OpenActivity(options, ref callerInfo);
				this.logger.Write( activity, level, LogRecordKind.CustomActivityEntry, formattingString, <#= Repeat( "arg{0}", i ) #>, null, ref callerInfo);
				return this.CreateActivity( activity );
			}
			catch ( Exception e )
			{
				this.ExceptionHandler?.OnInternalException( e );
				this.DisposeSafe( activity );
				return this.GetNullActivity();
			}
        }

/////

        /// <summary>
        /// Opens a custom activity with a description containing <#= i #> parameter<#= GetPlural( i ) #>.
        /// </summary>
        /// <param name="formattingString">The description of the activity, including parameters (e.g. <c>Writing {LineCount} line(s) in file {Path}</c>).</param>
<#
        GenerateXmlDoc( i );
#>
        /// <returns>A <see cref="Logger"/> representing the new activity.</returns>
        /// <remarks>The activity must be closed using <see cref="LogActivity.SetSuccess(string)"/>, <see cref="LogActivity.SetFailure(String)"/> or <see cref="LogActivity.SetException(Exception)"/>. </remarks>
		[MethodImpl(MethodImplOptions.NoInlining)]
        public LogActivity OpenActivity<<#= Repeat( "T{0}", i ) #>>( string formattingString, <#= Repeat( "T{0} arg{0}", i ) #> )
        {
            CallerInfo callerInfo = CallerInfo.GetDynamic(1);
			return OpenActivity( formattingString, <#= Repeat( "arg{0}", i ) #>, ref callerInfo );
        }


		 /// <excludeOverload />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public LogActivity OpenActivity<<#= Repeat( "T{0}", i ) #>>( string formattingString, <#= Repeat( "T{0} arg{0}", i ) #>, ref CallerInfo callerInfo )
        {
           return this.OpenActivity( LogActivityOptions.Default, formattingString, <#= Repeat( "arg{0}", i ) #>, ref callerInfo );
        }
	<#
    }
#>
	
	
	}

	partial class LogActivity
	{
	<#
    for (var i = 1; i <= 10; i++)
    {
#>

			/// <summary>
        /// Ends an activity (opened with <see cref="Logger.OpenActivity(string)"/>)
        /// with success and specifies a success message with <#= i #> parameter<#= GetPlural( i ) #>.
        /// </summary>
        /// <param name="formattingString">The success message with parameters, for instance <c>Written {Count} lines</c>.</param>
<#
        GenerateXmlDoc( i );
#>
  		public void SetSuccess<<#= Repeat( "T{0}", i ) #>>(string formattingString, <#= Repeat( "T{0} arg{0}", i ) #>)
        {
			CallerInfo nullRecordInfo = default;
            this.SetSuccess(formattingString, <#= Repeat( "arg{0}", i ) #>, ref nullRecordInfo );
        }

	  	 /// <excludeOverload />
        [EditorBrowsable(EditorBrowsableState.Never)]
		[SuppressMessage("Microsoft.Design", "CA1031")]
        public void SetSuccess<<#= Repeat( "T{0}", i ) #>>(string formattingString, <#= Repeat( "T{0} arg{0}", i ) #>, ref CallerInfo callerInfo)
        {
			if ( !this.RequiresCustomActivity( ref callerInfo ) )
                return;

			try
			{
				this.logger.Write( this.Context, this.ResolvedSuccessLevel, LogRecordKind.CustomActivitySuccess, formattingString, <#= Repeat( "arg{0}", i ) #>, null, ref callerInfo );
				this.Close( ref callerInfo );
			}
			catch ( Exception e )
			{
				this.ExceptionHandler?.OnInternalException( e );
			}
        }

		/// <summary>
        /// Ends an activity (opened with <see cref="Logger.OpenActivity(string)"/>)
        /// with failure and specifies a failure message with <#= i #> parameter<#= GetPlural( i ) #>.
        /// </summary>
        /// <param name="formattingString">The failure message with parameters, for instance <c>Written {Count} lines</c>.</param>
<#
        GenerateXmlDoc( i );
#>
  		public void SetFailure<<#= Repeat( "T{0}", i ) #>>(  string formattingString, <#= Repeat( "T{0} arg{0}", i ) #>)
        {
            CallerInfo nullRecordInfo = default;
            this.SetFailure( formattingString, <#= Repeat( "arg{0}", i ) #>, ref nullRecordInfo );
        }

		 /// <excludeOverload />
        [EditorBrowsable(EditorBrowsableState.Never)]
		[SuppressMessage("Microsoft.Design", "CA1031")]
        public void SetFailure<<#= Repeat( "T{0}", i ) #>>(  string formattingString, <#= Repeat( "T{0} arg{0}", i ) #>, ref CallerInfo callerInfo)
        {
			if ( !this.RequiresCustomActivity( ref callerInfo ) )
                return;

			try
			{
				this.logger?.Write( this.Context, this.ResolvedFailureLevel, LogRecordKind.CustomActivityFailure, formattingString, <#= Repeat( "arg{0}", i ) #>, null,  ref callerInfo );
				this.Close( ref callerInfo );
			}
			catch ( Exception e )
			{
				this.ExceptionHandler?.OnInternalException( e );
			}
        }

		<#
    }
#>
	}
	
   
   <#
    for (var i = 1; i <= 10; i++)
    {
#>

	namespace Custom.Messages
	{
		/// <summary>
		/// Encapsulates a text message with <#= i #> parameter<#= GetPlural( i ) #>. Use the <see cref="FormattedMessageBuilder"/> class to create an instance of this type.
		/// </summary>
	    [SuppressMessage("Microsoft.Performance","CA1815", Justification = "Equal is not a use case")]
	    [SuppressMessage("Microsoft.Design","CA1005:AvoidExcessiveParametersOnGenericTypes", Justification = "Recommended to use 'var' keyword.")]
		public readonly struct FormattedMessage<<#= Repeat( "T{0}", i ) #>> : IMessage
		{
			private readonly string formattingString;
			
			<#= Repeat( "private readonly T{0} arg{0}; ", i, "" ) #>

			
			[MethodImpl(MethodImplOptions.AggressiveInlining)] // To avoid copying the struct.
			internal FormattedMessage( string formattingString, <#= Repeat( "T{0} arg{0}", i ) #> )
			{
				this.formattingString = formattingString;
				<#= Repeat( "this.arg{0} = arg{0}; ", i, "" ) #>
			}

			void IMessage.Write( ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item )
			{
				recordBuilder.BeginWriteItem(item, new CustomLogRecordTextOptions(<#= i #>, null));
    
				FormattingStringParser parser = new FormattingStringParser( this.formattingString );
				ArraySegment<char> parameter;

				   <#
        for (var j = 1; j <= i; j++)
        {
#>

				recordBuilder.WriteCustomString( parser.GetNextSubstring() );
				parameter = parser.GetNextParameter();

				if ( parameter.Array == null )
				{
					throw new InvalidFormattingStringException("The formatting string must have exactly <#= i #> parameters.");
				}

				recordBuilder.WriteCustomParameter( <#= j - 1 #>, parameter, arg<#= j #>, CustomLogParameterOptions.FormattedStringParameter );

				<#
        }
#>

				recordBuilder.WriteCustomString( parser.GetNextSubstring() );

				if ( parser.GetNextParameter().Array != null )
				{
					throw new InvalidFormattingStringException("The formatting string must have exactly <#= i #> parameters.");
				}

				recordBuilder.EndWriteItem(item);


			}

			/// <inheritdoc />
			public override string ToString() => DebugMessageFormatter.Format( this );
		}

		 /// <summary>
		/// Encapsulates a semantic message with a <#= i #> number of parameter<#= GetPlural( i ) #>. Use the <see cref="SemanticMessageBuilder"/> class to create an instance of this type.
		/// </summary>
		[SuppressMessage("Microsoft.Performance","CA1815", Justification = "Equal is not a use case")]
		[SuppressMessage("Microsoft.Design","CA1005:AvoidExcessiveParametersOnGenericTypes", Justification = "Recommended to use 'var' keyword.")]
		public readonly struct SemanticMessage<<#= Repeat( "T{0}", i ) #>> : IMessage
		{
			private readonly string messageName;
			
			<#= Repeat( "private readonly string name{0}; ", i, "" ) #>
			<#= Repeat( "private readonly T{0} value{0}; ", i, "" ) #>

			#if AGGRESSIVE_INLINING
			[MethodImpl(MethodImplOptions.AggressiveInlining)] // To avoid copying the struct.
			#endif
			internal SemanticMessage( string messageName, <#= Repeat( "string name{0}, T{0} value{0}", i ) #> )
			{
				this.messageName = messageName;
				<#= Repeat( "this.name{0} = name{0}; ", i, "" ) #>
				<#= Repeat( "this.value{0} = value{0}; ", i, "" ) #>
			}

			void IMessage.Write( ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item )
			{
				recordBuilder.BeginWriteItem(item, new CustomLogRecordTextOptions(<#= i #>, this.messageName));

				   <#
        for (var j = 1; j <= i; j++)
        {
#>

				recordBuilder.WriteCustomParameter( <#= j - 1 #>, this.name<#= j #>, this.value<#= j #>, CustomLogParameterOptions.SemanticParameter );

				<#
        }
#>

				recordBuilder.EndWriteItem(item);
				
			}

			/// <inheritdoc />
			public override string ToString() => DebugMessageFormatter.Format( this );
		}

		
	
	}



	partial class FormattedMessageBuilder
	{
		
		/// <summary>
        /// Creates a formatted string with <#= i #> parameter<#= GetPlural( i ) #>.
        /// </summary>
        /// <param name="formattingString">The text of the log record, including parameters (e.g. <c>Opening {Path} file {ShareMode} sharing mode</c>).</param>
<#
        GenerateXmlDoc( i );
#>
#if AGGRESSIVE_INLINING
        [MethodImpl(MethodImplOptions.AggressiveInlining)] // To avoid copying the struct.
#endif
	    public static FormattedMessage<<#= Repeat( "T{0}", i ) #>> Formatted<<#= Repeat( "T{0}", i ) #>>(  string formattingString, <#= Repeat( "T{0} arg{0}", i ) #> )
        {
            return new FormattedMessage<<#= Repeat( "T{0}", i ) #>>( formattingString, <#= Repeat( "arg{0}", i ) #> );
        }
	}

	partial class SemanticMessageBuilder
	{
		/// <summary>
        /// Create a semantic message with <#= i #> parameter<#= GetPlural( i ) #> (using tuples).
        /// </summary>
        /// <param name="name">Name of the message.</param>
<#
        for (var j = 1; j <= i; j++)
        {
#>
		/// <typeparam name="T<#= j #>">Type of the <#= GetOrdinal( j ) #> parameter value.</typeparam>
		/// <param name="parameterName<#= j #>">Name of the <#= GetOrdinal( j ) #> parameter.</param>
		/// <param name="parameterValue<#= j #>">Name of the <#= GetOrdinal( j ) #> parameter.</param>
	<#
        }
#>
#if AGGRESSIVE_INLINING
        [MethodImpl(MethodImplOptions.AggressiveInlining)] // To avoid copying the struct.
#endif
	    public static  SemanticMessage<<#= Repeat( "T{0}", i ) #>> Semantic<<#= Repeat( "T{0}", i ) #>>(  string name, <#= Repeat( "string parameterName{0}, T{0} parameterValue{0}", i ) #> )
        {
            return new SemanticMessage<<#= Repeat( "T{0}", i ) #>>( name, <#= Repeat( "parameterName{0}, parameterValue{0}", i ) #> );
        }

	#if VALUE_TUPLE
		
		
		/// <summary>
        /// Create a semantic message with <#= i #> parameter<#= GetPlural( i ) #>.
        /// </summary>
        /// <param name="name">Name of the message.</param>
<#
        for (var j = 1; j <= i; j++)
        {
#>
		/// <typeparam name="T<#= j #>">Type of the <#= GetOrdinal( j ) #> parameter value.</typeparam>
		/// <param name="parameter<#= j #>">Name and value of the <#= GetOrdinal( j ) #> parameter wrapped as a tuple.</param>
	<#
        }
#>
#if AGGRESSIVE_INLINING
        [MethodImpl(MethodImplOptions.AggressiveInlining)] // To avoid copying the struct.
#endif
	    public static  SemanticMessage<<#= Repeat( "T{0}", i ) #>> Semantic<<#= Repeat( "T{0}", i ) #>>(  string name, <#= Repeat( "in (string Name,T{0} Value) parameter{0}", i ) #> )
        {
            return new SemanticMessage<<#= Repeat( "T{0}", i ) #>>( name, <#= Repeat( "parameter{0}.Name, parameter{0}.Value", i ) #> );
        }
	

	#endif

	}


	<#
    }
#>





	
}


<#+
    private static string Repeat( string format, int count )
    {
        var s = "";
        for (var i = 1; i <= count; i++)
        {
            if (i > 1) s += ", ";
            s += string.Format( format, i );
        }

        return s;
    }

    private static string Repeat( string format, int count, string separator )
    {
        var s = "";
        for (var i = 1; i <= count; i++)
        {
            if (i > 1) s += separator;
            s += string.Format( format, i );
        }

        return s;
    }

    private static string GetPlural( int count )
    {
        return count > 1 ? "s" : "";
    }

    private static string GetOrdinal( int count )
    {
        switch (count)
        {
            case 1:
                return "first";
            case 2:
                return "second";
            case 3:
                return "third";
            default:
                return count + "-th";
        }
    }

    private void GenerateXmlDoc( int count )
    {
        for (var i = 1; i <= count; i++)
        {
#>
		/// <typeparam name="T<#= i #>">Type of the <#= GetOrdinal( i ) #> parameter.</typeparam>
		/// <param name="arg<#= i #>">Value of the <#= GetOrdinal( i ) #> parameter.</param>
	<#+
        }
    }
#>
