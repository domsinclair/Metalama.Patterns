// THIS FILE IS T4-GENERATED.
// To edit, go to Logger.Generated.tt.
// To transform, run this: "C:\Program Files (x86)\Common Files\Microsoft Shared\TextTemplating\14.0\TextTransform.exe" Logger.Generated.tt
// The transformation is not automatic because we are in a shared project.

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>

// TODO: Split T4 template into separate files with common include.

using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;
using Flashtrace.Custom.Messages;

namespace Flashtrace
{
   <#
    for (var i = 1; i <= 10; i++)
    {
#>

	namespace Custom.Messages
	{
		/// <summary>
		/// Encapsulates a text message with <#= i #> parameter<#= GetPlural( i ) #>. Use the <see cref="FormattedMessageBuilder"/> class to create an instance of this type.
		/// </summary>
	    [SuppressMessage("Microsoft.Performance","CA1815", Justification = "Equal is not a use case")]
	    [SuppressMessage("Microsoft.Design","CA1005:AvoidExcessiveParametersOnGenericTypes", Justification = "Recommended to use 'var' keyword.")]
		public readonly struct FormattedMessage<<#= Repeat( "T{0}", i ) #>> : IMessage
		{
			private readonly string formattingString;
			
			<#= Repeat( "private readonly T{0} arg{0}; ", i, "" ) #>

			
			[MethodImpl(MethodImplOptions.AggressiveInlining)] // To avoid copying the struct.
			internal FormattedMessage( string formattingString, <#= Repeat( "T{0} arg{0}", i ) #> )
			{
				this.formattingString = formattingString;
				<#= Repeat( "this.arg{0} = arg{0}; ", i, "" ) #>
			}

			void IMessage.Write( ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item )
			{
				recordBuilder.BeginWriteItem(item, new CustomLogRecordTextOptions(<#= i #>, null));
    
				FormattingStringParser parser = new FormattingStringParser( this.formattingString );
				ArraySegment<char> parameter;

				   <#
        for (var j = 1; j <= i; j++)
        {
#>

				recordBuilder.WriteCustomString( parser.GetNextSubstring() );
				parameter = parser.GetNextParameter();

				if ( parameter.Array == null )
				{
					throw new InvalidFormattingStringException("The formatting string must have exactly <#= i #> parameters.");
				}

				recordBuilder.WriteCustomParameter( <#= j - 1 #>, parameter, arg<#= j #>, CustomLogParameterOptions.FormattedStringParameter );

				<#
        }
#>

				recordBuilder.WriteCustomString( parser.GetNextSubstring() );

				if ( parser.GetNextParameter().Array != null )
				{
					throw new InvalidFormattingStringException("The formatting string must have exactly <#= i #> parameters.");
				}

				recordBuilder.EndWriteItem(item);


			}

			/// <inheritdoc />
			public override string ToString() => DebugMessageFormatter.Format( this );
		}

		 /// <summary>
		/// Encapsulates a semantic message with a <#= i #> number of parameter<#= GetPlural( i ) #>. Use the <see cref="SemanticMessageBuilder"/> class to create an instance of this type.
		/// </summary>
		[SuppressMessage("Microsoft.Performance","CA1815", Justification = "Equal is not a use case")]
		[SuppressMessage("Microsoft.Design","CA1005:AvoidExcessiveParametersOnGenericTypes", Justification = "Recommended to use 'var' keyword.")]
		public readonly struct SemanticMessage<<#= Repeat( "T{0}", i ) #>> : IMessage
		{
			private readonly string messageName;
			
			<#= Repeat( "private readonly string name{0}; ", i, "" ) #>
			<#= Repeat( "private readonly T{0} value{0}; ", i, "" ) #>

			[MethodImpl(MethodImplOptions.AggressiveInlining)] // To avoid copying the struct.
			internal SemanticMessage( string messageName, <#= Repeat( "string name{0}, T{0} value{0}", i ) #> )
			{
				this.messageName = messageName;
				<#= Repeat( "this.name{0} = name{0}; ", i, "" ) #>
				<#= Repeat( "this.value{0} = value{0}; ", i, "" ) #>
			}

			void IMessage.Write( ICustomLogRecordBuilder recordBuilder, CustomLogRecordItem item )
			{
				recordBuilder.BeginWriteItem(item, new CustomLogRecordTextOptions(<#= i #>, this.messageName));

				   <#
        for (var j = 1; j <= i; j++)
        {
#>

				recordBuilder.WriteCustomParameter( <#= j - 1 #>, this.name<#= j #>, this.value<#= j #>, CustomLogParameterOptions.SemanticParameter );

				<#
        }
#>

				recordBuilder.EndWriteItem(item);
				
			}

			/// <inheritdoc />
			public override string ToString() => DebugMessageFormatter.Format( this );
		}

		
	
	}



	partial class FormattedMessageBuilder
	{
		
		/// <summary>
        /// Creates a formatted string with <#= i #> parameter<#= GetPlural( i ) #>.
        /// </summary>
        /// <param name="formattingString">The text of the log record, including parameters (e.g. <c>Opening {Path} file {ShareMode} sharing mode</c>).</param>
<#
        GenerateXmlDoc( i );
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] // To avoid copying the struct.
	    public static FormattedMessage<<#= Repeat( "T{0}", i ) #>> Formatted<<#= Repeat( "T{0}", i ) #>>(  string formattingString, <#= Repeat( "T{0} arg{0}", i ) #> )
        {
            return new FormattedMessage<<#= Repeat( "T{0}", i ) #>>( formattingString, <#= Repeat( "arg{0}", i ) #> );
        }
	}

	partial class SemanticMessageBuilder
	{
		/// <summary>
        /// Create a semantic message with <#= i #> parameter<#= GetPlural( i ) #> (using tuples).
        /// </summary>
        /// <param name="name">Name of the message.</param>
<#
        for (var j = 1; j <= i; j++)
        {
#>
		/// <typeparam name="T<#= j #>">Type of the <#= GetOrdinal( j ) #> parameter value.</typeparam>
		/// <param name="parameterName<#= j #>">Name of the <#= GetOrdinal( j ) #> parameter.</param>
		/// <param name="parameterValue<#= j #>">Name of the <#= GetOrdinal( j ) #> parameter.</param>
	<#
        }
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] // To avoid copying the struct.
	    public static  SemanticMessage<<#= Repeat( "T{0}", i ) #>> Semantic<<#= Repeat( "T{0}", i ) #>>(  string name, <#= Repeat( "string parameterName{0}, T{0} parameterValue{0}", i ) #> )
        {
            return new SemanticMessage<<#= Repeat( "T{0}", i ) #>>( name, <#= Repeat( "parameterName{0}, parameterValue{0}", i ) #> );
        }

		/// <summary>
        /// Create a semantic message with <#= i #> parameter<#= GetPlural( i ) #>.
        /// </summary>
        /// <param name="name">Name of the message.</param>
<#
        for (var j = 1; j <= i; j++)
        {
#>
		/// <typeparam name="T<#= j #>">Type of the <#= GetOrdinal( j ) #> parameter value.</typeparam>
		/// <param name="parameter<#= j #>">Name and value of the <#= GetOrdinal( j ) #> parameter wrapped as a tuple.</param>
	<#
        }
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)] // To avoid copying the struct.
	    public static  SemanticMessage<<#= Repeat( "T{0}", i ) #>> Semantic<<#= Repeat( "T{0}", i ) #>>(  string name, <#= Repeat( "in (string Name,T{0} Value) parameter{0}", i ) #> )
        {
            return new SemanticMessage<<#= Repeat( "T{0}", i ) #>>( name, <#= Repeat( "parameter{0}.Name, parameter{0}.Value", i ) #> );
        }
	}
	<#
    }
#>





	
}


<#+
    private static string Repeat( string format, int count )
    {
        var s = "";
        for (var i = 1; i <= count; i++)
        {
            if (i > 1) s += ", ";
            s += string.Format( format, i );
        }

        return s;
    }

    private static string Repeat( string format, int count, string separator )
    {
        var s = "";
        for (var i = 1; i <= count; i++)
        {
            if (i > 1) s += separator;
            s += string.Format( format, i );
        }

        return s;
    }

    private static string GetPlural( int count )
    {
        return count > 1 ? "s" : "";
    }

    private static string GetOrdinal( int count )
    {
        switch (count)
        {
            case 1:
                return "first";
            case 2:
                return "second";
            case 3:
                return "third";
            default:
                return count + "-th";
        }
    }

    private void GenerateXmlDoc( int count )
    {
        for (var i = 1; i <= count; i++)
        {
#>
		/// <typeparam name="T<#= i #>">Type of the <#= GetOrdinal( i ) #> parameter.</typeparam>
		/// <param name="arg<#= i #>">Value of the <#= GetOrdinal( i ) #> parameter.</param>
	<#+
        }
    }
#>
